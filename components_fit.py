#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Jan 13 22:08:54 2021

@author: jan
"""
import numpy as np
from sklearn.mixture import GaussianMixture
import matplotlib as plt
from scipy.stats import gaussian_kde
import scipy

class GmFit:
    
    def normaldist(self, loc, stdw, size):
        
        ndist = np.random.normal(loc, stdw, size)
        
        return (ndist)
    
    def getIntervalls(self, ndist, highscore, components):
        
        if components % components == 0:
            perlabel = components ** (1/2)
            n_label = int(perlabel)
        else:
            print("n components should not dividable by 2!")
        
        size = highscore/perlabel
        intervalls = []
        lowX = 0
        lowY = 0
        
        for x in range(0,n_label):
            highX = lowX + size
            for y in range(0,n_label):
                highY = lowY + size 
                count = 0
            
                for i in ndist:
                    #print(i)
                    if (i[0] <highX and i[0]>lowX) and (i[1] <highY and i[1]>lowY):
                        count += 1
                    # print(i)
            
            # intervall = [low,high,count]
                intervalls.append(count)
                lowY = lowY + size
            lowY = 0
            lowX = lowX + size
        
        return (intervalls)
    
    
    def emAnalyse(self, X_train, n_cgauss):
        
        n_stdwX = []
        n_stdwY = []
        
        gmm = GaussianMixture(n_components=n_cgauss)
        gmm.fit(X_train)
        
        loc = gmm.means_
        covariances = gmm.covariances_
        weight = gmm.weights_
        #print(covariances)
        for i in range(0, (len(covariances))):
            
            dist_matrix = covariances[i]
            stdwX = ((dist_matrix[0])[0]) ** (1/2)
            stdwY = ((dist_matrix[1])[1]) ** (1/2)
            
            n_stdwX.append(stdwX)
            n_stdwY.append(stdwY)
            
        
        return (loc, n_stdwX, n_stdwY, weight)
    
    #Get differences between distributions generated by parameters from Gaussian
    #Mixture Model and original distribution by fitting n components from
    #1 - n_components.
    def getDifference(self, distribution, n_components):
        
        all_diffs =[]
        size = len(distribution)
        
        for z in range(1, n_components+1):
        
            n_loc, n_stdwX, n_stdwY, n_weights = GmFit().emAnalyse(distribution, n_cgauss=z)
            # print(n_stdwX)
            # print(n_stdwY)
            
            # GmFit().contourPlot(distribution)
            reference_distX = []
            reference_distY = []
        
            for k in range(0, len(n_loc)):
                
                component_size = int(size * (n_weights[k]))
                component_locX = int((n_loc[k])[0])
                component_locY = int((n_loc[k])[1])
                component_stdwX = n_stdwX[k]
                component_stdwY = n_stdwY[k]
                component_distX = GmFit().normaldist(component_locX, component_stdwX, component_size)
                component_distY = GmFit().normaldist(component_locY, component_stdwY, component_size)
                
                reference_distX.extend(component_distX)
                reference_distY.extend(component_distY)
        
            reference_distribution= []
            for i in range(0, len(reference_distX)):
                reference_distribution.append([reference_distX[i],reference_distY[i]])
            
            # GmFit().contourPlot(reference_distribution)
            diff = 0
            ori_intervalls = GmFit().getIntervalls(distribution, 100, 100)
            new_intervalls = GmFit().getIntervalls(reference_distribution, 100, 100)
            
            for j in range(len(ori_intervalls)):
                raw_diff = (ori_intervalls[j])-(new_intervalls[j])
                single_diff = (raw_diff**2)**(1/2)
                diff = diff + single_diff
        
        
            all_diffs.append(diff)
        
        return (all_diffs)
        
    
    def evaluateComponents(self, all_diffs):
          
        x = []
        count= 0
        for i in range(0, len(all_diffs)):
            
            x.append(all_diffs[0]/all_diffs[i])
            
        for j in range(0, len(x)):
            
            count +=1
            if x[j]>x[j+1]:
                break
            
            else:
                pass
                
        return (x, count)
        
         
if __name__ == '__main__':
    
    # from TestdataMaker import Testdata_Maker

    n_components = 15
    # #Parameters for the first gaussian distribution:
    # location_ATAC = 50
    # location_CHIP = 50
    # gain_ATAC = 10
    # gain_CHIP = 30
    # size = 5000 
    # rotation = 45
    
    # #Parameters for the second gaussian distribution:
    # secondDistribution = True
    # location_ATAC_2 = 70
    # gain_ATAC_2 = 10
    # location_CHIP_2 = 70
    # gain_CHIP_2 = 10
    # size_2 = 3000  
    # rotation_2 = 0    
    
    # #Parameters for Gaussian Noise:
    # gaussian_Noise = True
    # noise_loop = 50
    # location_ATAC_Noise = 50
    # location_CHIP_Noise = 50
    # standard_deviation_loc_ATAC = 25
    # standard_deviation_loc_CHIP = 25
    # gain_ATAC_Noise = 10
    # gain_CHIP_Noise = 10
    # standard_deviation_gain_ATAC = 1
    # standard_deviation_gain_CHIP = 1
    # size_GaussianNoise = 200
    # standard_deviation_size_GaussianNoise = 100
    
    # #Parameters for linear noise:
    # noise = True
    # size_noise = 1000

    # #Index of the parameter list
    # # 0. loop
    # # 1. location_ATAC
    # # 2. stda_loc_ATAC
    # # 3. gain_ATAC
    # # 4. stda_gain_ATAC
    # # 5. location_CHIP
    # # 6. stda_loc_CHIP
    # # 7. gain_CHIP
    # # 8. stda_gain_CHIP
    # # 9. size
    # # 10.stda_size
    
    # param = []
    # param.append(noise_loop)
    # param.append(location_ATAC_Noise)
    # param.append(standard_deviation_loc_ATAC)
    # param.append(gain_ATAC_Noise)
    # param.append(standard_deviation_gain_ATAC)    
    # param.append(location_CHIP_Noise)
    # param.append(standard_deviation_loc_CHIP)
    # param.append(gain_CHIP_Noise)
    # param.append(standard_deviation_gain_CHIP)
    # param.append(size_GaussianNoise)
    # param.append(standard_deviation_size_GaussianNoise)

    
    # #Testing:
    
    
    # #Execute:
    # scores_array = Testdata_Maker().getScoresArray(location_ATAC, location_CHIP, gain_ATAC, gain_CHIP, size)

    # rotated = Testdata_Maker().rotate(scores_array, location_ATAC, location_CHIP, rotation)  
    # scores_array = rotated
    
    # if secondDistribution:
        
    #     scores_array_2 = Testdata_Maker().getScoresArray(location_ATAC_2, location_CHIP_2, gain_ATAC_2, gain_CHIP_2, size_2)

    #     rotated = Testdata_Maker().rotate(scores_array_2, location_ATAC_2, location_CHIP_2, rotation_2)  
    #     scores_array.extend(rotated)
    
    # if noise:
    #     randomized = Testdata_Maker().randomeNoise(size_noise, scores_array)
    #     scores_array = randomized
    
    # if gaussian_Noise:
    #     g_noise = Testdata_Maker().gaussianNoise(param)
    #     scores_array.extend(g_noise)
     
    # filtered = Testdata_Maker().cutoff(scores_array)
    # distribution = filtered
    
    from Interface_Scoring import LoadPickle as SC
    
    distribution = SC().loadData(path='/home/jan/python-workspace/angewendete_daten_analyse/testsets/calculated_data_3.pickle')

    all_diffs = GmFit().getDifference(distribution, n_components)
    
    print(all_diffs)
    x, count = GmFit().evaluateComponents(all_diffs)
    # plt.pyplot.plot(all_diffs)
    dif = np.diff(all_diffs)
    difdif = np.diff(dif)
    print(x)
    print(count)
    plt.pyplot.plot(all_diffs)
        