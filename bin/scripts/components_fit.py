#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Jan 13 22:08:54 2021

@author: jan
"""
import numpy as np
from sklearn.mixture import GaussianMixture
import matplotlib as plt
from kneed import KneeLocator

class GmFit:
    
    #Generate gaussian distribution
    def normaldist(self, loc, stdw, size):
        """
        generate normal distribution by numy.random.normal
        
        Parameters
        ----------
        loc: TYPE: int
            location of the normal distribution (X/Y)
        stdw: TYPE: float64
            standard deviation
        size: TYPE: int
            size

        Returns
        -------
        ndist: TYPE: Array of float64
            normal distribution 
        """
        #generate normal distribution
        ndist = np.random.normal(loc, stdw, size)
        
        return (ndist)
    
    #Make intervalls to compare original distribution with generated distribution
    def getIntervalls(self, ndist, intervall_size):
        """
        This Method calculates Intervalls of a distribution. Therefore the size is defined 
        by rows and columns

        Parameters
        ----------
        ndist: TYPE: Array of float64 
            Distribution to calculate the intervalls
        rows: TYPE: int
            Number of rows
        columns: TYPE: int
            Number of columns

        Returns
        -------
        intervalls: TYPE: list of int
            

        """
        #check if column size useable 
        if intervall_size % 2 == 0:
            #calculating stepsize
            size = intervall_size ** (1/2)
            n_label = int(size)
        else:
            raise Exception("intervall_size should be dividable by 2!")
        
        #initialysing variables
        intervalls = []
        lowX = 0
        lowY = 0
        
        #loop trough all intervalls by x and y component in calculated stepsize
        #By defining lowest and highest score of an intervall
        for x in range(0,n_label):
            #define new highscore of the intervall component
            highX = lowX + size
            for y in range(0,n_label):
                #define new highscore of the intervall component
                highY = lowY + size 
                count = 0
                
                #loop trough all data points and count how many in the current intervall component
                for i in ndist:
                    #print(i)
                    if (i[0] < highX and i[0] > lowX) and (i[1] < highY and i[1] > lowY):
                        count += 1
            
                #append counted number
                intervalls.append(count)
                #define new lowest score 
                lowY = lowY + size
            #reset lowest score of x-component
            lowY = 0
            #define new lowest score
            lowX = lowX + size
        
        return (intervalls)
    
    #EM algorythmus fit gaussian distributions in given distribution
    def emAnalyse(self, distribution, n_cgauss):
        """
        Method to analyse a distribution via EM-algorythm. Therefore Gaussian 
        Mixture Models from sklearn is used.
        

        Parameters
        ----------
        distribution: Type: Array of float64 
            Distribution to be analyzed
        n_cgauss: Type: int 
            number of gaussian distributions to be fitted (number of components)
        Returns
        -------
        loc: TYPE: Array of float64 
            Array of locations of the fitted components
        n_stdwX: TYPE: list of float64
            List of standard deviations of the x-values
        n_stdwY: TYPE: list of float64 
            List of standard deviations of the y-values
        weight: TYPE: Array of float64 
            List of the weigts of the fitted components

        """
        
        n_stdwX = []
        n_stdwY = []
        
        gmm = GaussianMixture(n_components=n_cgauss)
        gmm.fit(distribution)
        
        loc = gmm.means_
        covariances = gmm.covariances_
        weight = gmm.weights_

        #get variables of each components
        for i in range(0, len(covariances)):
            
            dist_matrix = covariances[i]
            #calculate standard deviations from dispersion matrices
            stdwX = ((dist_matrix[0])[0]) ** (1/2)
            stdwY = ((dist_matrix[1])[1]) ** (1/2)
            
            n_stdwX.append(stdwX)
            n_stdwY.append(stdwY)
            
        
        return (loc, n_stdwX, n_stdwY, weight)
    
    #Get differences between distributions generated by parameters from Gaussian
    #Mixture Model and original distribution by fitting n components from
    #1 - n_components.
    def getDifference(self, distribution, n_components):
        """
        Method to calculate the space between a input distribution and generated 
        distributiuons. Therefore gaussian distibutions called components, are fit in the original distribution. 
        The parameters of the components is then used to generate a new distribution.
        Afterwards the new distribution is compared with the new distribution. To do that 
        the space between the original and new distribution is calculated.
        To evaluate the best fit (number of componets) the latter is repeated for 
        n = 0 to n = n_components.
        
        Parameters
        ----------
        distribution: TYPE: Array of float64
            Original distribution from ATAC and CHIP data (numpy array of float64 vectors)
        n_components: TYPE: int
            Max number of components to be fit into the original 
            distribution

        Returns
        -------
        all_diffs: TYPE: list of float
            List of all calculated differences

        """
        
        all_diffs =[]
        size = len(distribution)
        
        #create distributions from 1 component to n_components
        for z in range(1, n_components+1):
            #calculate parameters to generate the distributions
            n_loc, n_stdwX, n_stdwY, n_weights = GmFit.emAnalyse(self, distribution, n_cgauss=z)
            reference_distX = []
            reference_distY = []
        
            #generate reference distribution from parameter lists 1D
            for k in range(0, len(n_loc)):

                component_size = int(size * (n_weights[k]))
                component_locX = int((n_loc[k])[0])
                component_locY = int((n_loc[k])[1])
                component_stdwX = n_stdwX[k]
                component_stdwY = n_stdwY[k]
                component_distX = GmFit.normaldist(self, component_locX, component_stdwX, component_size)
                component_distY = GmFit.normaldist(self, component_locY, component_stdwY, component_size)
                
                reference_distX.extend(component_distX)
                reference_distY.extend(component_distY)
        
            #combine X and Y values
            reference_distribution= []
            for i in range(0, len(reference_distX)):
                reference_distribution.append([reference_distX[i],reference_distY[i]])
            
            #get intervalls of ori distribution and reference distribution
            diff = 0
            ori_intervalls = GmFit.getIntervalls(self, distribution, 100)
            new_intervalls = GmFit.getIntervalls(self, reference_distribution, 100)
            
            #calculate differences
            for j in range(len(ori_intervalls)):
                raw_diff = (ori_intervalls[j])-(new_intervalls[j])
                single_diff = (raw_diff**2)**(1/2)
                diff = diff + single_diff
        
        
            all_diffs.append(diff)
        
        return (all_diffs)
        
    #Evaluate number of components
    def evaluate_by_cutoff(self, all_diffs):
        """
        NOT USED IN THE FINAL VERSION
        =============================
        
        Evaluate components from calculated differences from 
        method getDifference
        
        Parameters
        ----------
        all_diffs: TYPE: list of float 
            List of all differences between generated distibutions 
            and original distribution.

        Returns
        -------
        rates: TYPE: List of all calculated rates
        count: TYPE: int
            evaluated number of components
        """
        
        rates = []
        count = 0
        cutoff= 0
        for i in range(0, len(all_diffs)):
            
            rates.append(all_diffs[0]/all_diffs[i])
            
        for j in range(0, len(rates)):
            
            if rates[j]>rates[j+1]:
                cutoff = all_diffs[j]*1.05
                break
            
            else:
                pass
        # print("Cutoff: ")
        # print(cutoff)
        for k in all_diffs:
            count += 1
            if k < cutoff:
                break
        
        return (rates, count)
        
        
    # def evaluate_componets(scores_array, max_components):
        
    #     all_diffs = GmFit().getDifference(scores_array, max_components)
        
    #     x, count = GmFit().evaluate(all_diffs)
        
    #     return (count)
    
    def evaluate(self, all_diffs):
        """
        Evaluate components from calculated differences from 
        method getDifference

        Parameters
        ----------
        all_diffs: TYPE: list of float
            Evaluate components from calculated differences from 
            method getDifference

        Returns
        -------
        n: TYPE: int
            number of components

        """
        x = np.arange(1,(len(all_diffs))+1,1)
        y = all_diffs
        try:
            kneedle = KneeLocator(x, y, S=1.0, curve="convex", direction="decreasing")
        
            n = kneedle.knee
        except:
            raise Exception("No knee found, coud not determine number of components. Try to set components manually")
        return n
        

if __name__ == '__main__':
    """
    Testing the script 
    """
    
    # from TestdataMaker import Testdata_Maker

    n_components = 7
    # #Parameters for the first gaussian distribution:
    # location_ATAC = 50
    # location_CHIP = 50
    # gain_ATAC = 10
    # gain_CHIP = 30
    # size = 5000 
    # rotation = 45
    
    # #Parameters for the second gaussian distribution:
    # secondDistribution = True
    # location_ATAC_2 = 70
    # gain_ATAC_2 = 10
    # location_CHIP_2 = 70
    # gain_CHIP_2 = 10
    # size_2 = 3000  
    # rotation_2 = 0    
    
    # #Parameters for Gaussian Noise:
    # gaussian_Noise = True
    # noise_loop = 50
    # location_ATAC_Noise = 50
    # location_CHIP_Noise = 50
    # standard_deviation_loc_ATAC = 25
    # standard_deviation_loc_CHIP = 25
    # gain_ATAC_Noise = 10
    # gain_CHIP_Noise = 10
    # standard_deviation_gain_ATAC = 1
    # standard_deviation_gain_CHIP = 1
    # size_GaussianNoise = 200
    # standard_deviation_size_GaussianNoise = 100
    
    # #Parameters for linear noise:
    # noise = True
    # size_noise = 1000

    # #Index of the parameter list
    # # 0. loop
    # # 1. location_ATAC
    # # 2. stda_loc_ATAC
    # # 3. gain_ATAC
    # # 4. stda_gain_ATAC
    # # 5. location_CHIP
    # # 6. stda_loc_CHIP
    # # 7. gain_CHIP
    # # 8. stda_gain_CHIP
    # # 9. size
    # # 10.stda_size
    
    # param = []
    # param.append(noise_loop)
    # param.append(location_ATAC_Noise)
    # param.append(standard_deviation_loc_ATAC)
    # param.append(gain_ATAC_Noise)
    # param.append(standard_deviation_gain_ATAC)    
    # param.append(location_CHIP_Noise)
    # param.append(standard_deviation_loc_CHIP)
    # param.append(gain_CHIP_Noise)
    # param.append(standard_deviation_gain_CHIP)
    # param.append(size_GaussianNoise)
    # param.append(standard_deviation_size_GaussianNoise)

    
    # #Testing:
    
    
    # #Execute:
    # scores_array = Testdata_Maker().getScoresArray(location_ATAC, location_CHIP, gain_ATAC, gain_CHIP, size)

    # rotated = Testdata_Maker().rotate(scores_array, location_ATAC, location_CHIP, rotation)  
    # scores_array = rotated
    
    # if secondDistribution:
        
    #     scores_array_2 = Testdata_Maker().getScoresArray(location_ATAC_2, location_CHIP_2, gain_ATAC_2, gain_CHIP_2, size_2)

    #     rotated = Testdata_Maker().rotate(scores_array_2, location_ATAC_2, location_CHIP_2, rotation_2)  
    #     scores_array.extend(rotated)
    
    # if noise:
    #     randomized = Testdata_Maker().randomeNoise(size_noise, scores_array)
    #     scores_array = randomized
    
    # if gaussian_Noise:
    #     g_noise = Testdata_Maker().gaussianNoise(param)
    #     scores_array.extend(g_noise)
     
    # filtered = Testdata_Maker().cutoff(scores_array)
    # distribution = filtered
    
    from interface_scoring import LoadPickle as SC
    
    distribution = SC().loadData(path='/home/jan/python-workspace/angewendete_daten_analyse/testsets/calculated_data_3.pickle')

    all_diffs = GmFit().getDifference(distribution, n_components)
    x = GmFit().evaluate(all_diffs)
    # k = GmFit().getknee(all_diffs)
    # print("knee: ")
    # print(k)
    count = GmFit().evaluate(all_diffs)
    plt.pyplot.plot(all_diffs)
    dif = np.diff(all_diffs)
    difdif = np.diff(dif)
    print(count)
    #plt.pyplot.plot(all_diffs)
        